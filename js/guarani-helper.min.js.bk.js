if (!window.UtnBaHelper) window.UtnBaHelper = {};
UtnBaHelper.ApiConnector = function () {

	const CLIENT = `CHROME@${chrome.runtime.getManifest().version}`;
	const BASE_API_URL = "https://www.pablomatiasgomez.com.ar/utnba-helper/v2";

	let logMessage = function (method, isError, message) {
		return postData(BASE_API_URL + "/log", {
			method: method,
			error: isError,
			message: message
		});
	};

	let logUserStat = function (hashedStudentId, pesoAcademico, passingGradesAverage, allGradesAverage, passingGradesCount, failingGradesCount) {
		return postData(BASE_API_URL + "/user-stats", {
			hashedStudentId: hashedStudentId,
			pesoAcademico: pesoAcademico,
			passingGradesAverage: passingGradesAverage,
			allGradesAverage: allGradesAverage,
			passingGradesCount: passingGradesCount,
			failingGradesCount: failingGradesCount
		});
	};

	let postClassSchedules = function (classSchedules) {
		return postData(BASE_API_URL + "/class-schedules", classSchedules);
	};

	let postProfessorSurveys = function (surveys) {
		return postData(BASE_API_URL + "/professor-surveys", surveys);
	};

	let postCourses = function (courses) {
		return postData(BASE_API_URL + "/courses", courses);
	}

	let postData = function (url, data) {
		return makeRequest({
			url: url,
			method: 'POST',
			headers: {
				"X-Client": CLIENT,
				"Content-type": "application/json; charset=utf-8"
			},
			body: JSON.stringify(data)
		});
	};

	// ------

	let getPreviousProfessors = function (previousProfessorsRequest) {
		return postData(BASE_API_URL + "/previous-professors", previousProfessorsRequest);
	};

	let searchProfessors = function (query) {
		return getData(BASE_API_URL + "/professors?q=" + encodeURIComponent(query));
	};

	let getProfessorSurveysAggregate = function (professorName) {
		return getData(BASE_API_URL + "/aggregated-professor-surveys?professorName=" + encodeURIComponent(professorName));
	};

	let getClassesForProfessor = function (professorName, offset, limit) {
		return getClassesSchedules(null, professorName, offset, limit);
	};

	let searchCourses = function (query) {
		return getData(BASE_API_URL + "/courses?q=" + encodeURIComponent(query));
	};

	let getPlanCourses = function (planCode) {
		return getData(BASE_API_URL + "/courses?planCode=" + encodeURIComponent(planCode));
	};

	let getClassesForCourse = function (courseCode, offset, limit) {
		return getClassesSchedules(courseCode, null, offset, limit);
	};

	let getClassesSchedules = function (courseCode, professorName, offset, limit) {
		let params = {
			offset: offset,
			limit: limit
		};
		if (courseCode) params.courseCode = courseCode;
		if (professorName) params.professorName = professorName;
		return getData(BASE_API_URL + "/class-schedules?" + buildQueryParams(params));
	};

	let getData = function (url) {
		return makeRequest({
			url: url,
			method: 'GET',
			headers: {
				"X-Client": CLIENT
			}
		});
	};

	// ---

	let makeRequest = function (options) {
		// TODO this is duplicated in Utils.backgroundFetch.
		return new Promise((resolve, reject) => {
			chrome.runtime.sendMessage(options, response => (response && response.errorStr) ? reject(new Error(response.errorStr)) : resolve(response));
		});
	};

	let buildQueryParams = function (params) {
		return Object.entries(params)
			.map(entry => `${encodeURIComponent(entry[0])}=${encodeURIComponent(entry[1])}`)
			.join("&");
	};


	// Public
	return {
		// POSTs:
		logMessage: logMessage,
		logUserStat: logUserStat,
		postClassSchedules: postClassSchedules,
		postProfessorSurveys: postProfessorSurveys,
		postCourses: postCourses,

		// GETs:
		getPreviousProfessors: getPreviousProfessors,
		searchProfessors: searchProfessors,
		getProfessorSurveysAggregate: getProfessorSurveysAggregate,
		getClassesForProfessor: getClassesForProfessor,
		searchCourses: searchCourses,
		getPlanCourses: getPlanCourses,
		getClassesForCourse: getClassesForCourse,
	};
};
if (!window.UtnBaHelper) window.UtnBaHelper = {};
UtnBaHelper.Consts = {

	HOURS: {
		"MORNING": {
			0: {start: "7:45", end: "8:30"},
			1: {start: "8:30", end: "9:15"},
			2: {start: "9:15", end: "10:00"},
			3: {start: "10:15", end: "11:00"},
			4: {start: "11:00", end: "11:45"},
			5: {start: "11:45", end: "12:30"},
			6: {start: "12:30", end: "13:15"}
		},
		"AFTERNOON": {
			0: {start: "13:30", end: "14:15"},
			1: {start: "14:15", end: "15:00"},
			2: {start: "15:00", end: "15:45"},
			3: {start: "16:00", end: "16:45"},
			4: {start: "16:45", end: "17:30"},
			5: {start: "17:30", end: "18:15"},
			6: {start: "18:15", end: "19:00"},
		},
		"NIGHT": {
			0: {start: "18:15", end: "19:00"},
			1: {start: "19:00", end: "19:45"},
			2: {start: "19:45", end: "20:30"},
			3: {start: "20:45", end: "21:30"},
			4: {start: "21:30", end: "22:15"},
			5: {start: "22:15", end: "23:00"},
		}
	},

	DAYS: {
		"MONDAY": "Lunes",
		"TUESDAY": "Martes",
		"WEDNESDAY": "Miercoles",
		"THURSDAY": "Jueves",
		"FRIDAY": "Viernes",
		"SATURDAY": "Sabado",
	},

	TIME_SHIFTS: {
		"MORNING": "Mañana",
		"AFTERNOON": "Tarde",
		"NIGHT": "Noche",
	},

	// Doesn't have to be exact... just using March 10th.
	NEW_GRADES_REGULATION_DATE: new Date(2017, 2, 10),
	WEIGHTED_GRADES: {
		// "Ordenanza 1549"
		1: 1,
		2: 2.67,
		3: 4.33,
		4: 6,
		5: 6.67,
		6: 7.33,
		7: 8,
		8: 8.67,
		9: 9.33,
		10: 10
	},

};
function LoggedOutError() {
	this.name = 'LoggedOutError';
	this.message = "User has been logged out!";
	this.stack = (new Error()).stack;
}

LoggedOutError.prototype = new Error;


function RedirectedToHomeError() {
	this.name = 'RedirectedToHomeError';
	this.message = "Request has been redirected to home";
	this.stack = (new Error()).stack;
}

RedirectedToHomeError.prototype = new Error;


// GuaraniBackendError is thrown when the Guarani's server is not working correctly.
function GuaraniBackendError(error) {
	this.name = 'GuaraniBackendError';
	this.message = "Guarani's backend error";
	this.stack = (new Error()).stack;
	this.error = error;
}

GuaraniBackendError.prototype = new Error;
if (!window.UtnBaHelper) window.UtnBaHelper = {};
UtnBaHelper.Utils = function (apiConnector) {
	// TODO utils eventually shouldn't be instantiated and should be a set of functions.
	//  But we need to get rid of using apiConnector here.

	let failedToFetchErrors = 0;

	const delay = (delayMs) => {
		return result => new Promise(resolve => setTimeout(() => resolve(result), delayMs));
	}

	// TODO this is duplicated in the ApiConnector.
	let backgroundFetch = function (options) {
		return new Promise((resolve, reject) => {
			chrome.runtime.sendMessage(options, response => (response && response.errorStr) ? reject(new Error(response.errorStr)) : resolve(response));
		});
	};

	let injectScript = function (filePath) {
		let script = document.createElement('script');
		script.type = 'text/javascript';
		script.src = chrome.runtime.getURL(filePath);
		document.head.appendChild(script);
	};

	let stringifyError = function (error) {
		if (error instanceof Error) {
			// Stack can include the message in some errors, but not in all cases.
			let message = error.toString();
			if (error.stack.startsWith(message)) {
				return error.stack;
			} else {
				return message + "\n" + error.stack;
			}
		}
		if (typeof error === "object") {
			return JSON.stringify(error);
		}
		return error + "";
	};

	let wrapError = function (message, error) {
		let newError = new Error(message);
		// Remove this function (wrapError) call from the stack...
		let newStack = newError.stack.split("\n");
		newStack.splice(1, 1);
		newStack = newStack.join("\n");
		newError.stack = `${newStack}\nCaused by: ${error.stack}`;
		return newError;
	};

	/**
	 * Wraps a function that is triggered from an async event, and handles errors by logging them to the api.
	 */
	let runAsync = function (name, fn) {
		// Start with Promise.resolve() as we don't know if fn returns promise or not.
		return Promise.resolve().then(() => {
			return fn();
		}).catch(e => {
			console.error(`Error while executing ${name}`, e);
			// Not logging LoggedOutError nor GuaraniBackendError.
			if (e instanceof LoggedOutError || e instanceof GuaraniBackendError) return;
			let errStr = stringifyError(e);
			// Skip first 5 Failed to fetch errors. We only want to know about these if it's failing for every request.
			// These are usually related to the user closing the tab, dns not resolving, etc, but we cannot get the details.
			if (errStr.includes("Failed to fetch") && ++failedToFetchErrors <= 3) return;
			return apiConnector.logMessage(name, true, errStr);
		});
	};

	let waitForElementToHide = function (selector) {
		return new Promise((resolve) => {
			let check = () => {
				if (!$(selector).is(":visible")) {
					resolve();
				} else {
					setTimeout(check, 100);
				}
			};
			check();
		});
	};

	// ----

	let getSchedulesAsString = function (schedules) {
		if (!schedules) return "-";
		return schedules
			.map(schedule =>
				UtnBaHelper.Consts.DAYS[schedule.day] + " (" + UtnBaHelper.Consts.TIME_SHIFTS[schedule.shift] + ") " +
				UtnBaHelper.Consts.HOURS[schedule.shift][schedule.firstHour].start + "hs a " + UtnBaHelper.Consts.HOURS[schedule.shift][schedule.lastHour].end + "hs")
			.join(" y ");
	};

	let getColorForAvg = function (avg) {
		if (avg < 60) {
			return "#D51C26";
		} else if (avg >= 80) {
			return "#19B135";
		} else {
			return "#F4D224";
		}
	};

	let getOverallScoreSpan = function (overallScore) {
		return `<span style="border: 1px solid grey; background-color: ${getColorForAvg(overallScore)}">${overallScore}</span>`;
	};

	let getProfessorLi = function (professor) {
		let fontSize = professor.kind === "DOCENTE" ? "13px" : "11px";
		if (typeof professor.overallScore === "undefined") {
			// If we do not have surveys we do not show the score nor the link.
			return `<li style="font-size: ${fontSize}">${professor.name} (${professor.role})</li>`;
		}
		return `<li style="font-size: ${fontSize}">
			${getOverallScoreSpan(professor.overallScore)}
			<a class="no-ajax" href="${UtnBaHelper.CustomPages.getProfessorSurveyResultsUrl(professor.name)}" target="_blank">${professor.name}</a> (${professor.role})
		</li>`;
	};

	// Public
	return {
		// Related to the extension:
		delay: delay,
		backgroundFetch: backgroundFetch,
		injectScript: injectScript,
		wrapError: wrapError,
		runAsync: runAsync,
		waitForElementToHide: waitForElementToHide,

		//--
		getSchedulesAsString: getSchedulesAsString,
		getColorForAvg: getColorForAvg,
		getOverallScoreSpan: getOverallScoreSpan,
		getProfessorLi: getProfessorLi,
	};
};
if (!window.UtnBaHelper) window.UtnBaHelper = {};
UtnBaHelper.Store = function () {

	const HASHED_STUDENT_ID_DATASTORE_KEY = "UtnBaHelper.HashedStudentId";

	// TODO we could remove this in some days, this is to avoid uses that have the storage full (because of old urls..)
	// noinspection JSIgnoredPromiseFromCall
	chrome.storage.sync.remove("UtnBaHelper.SurveyFormData")

	let readHashedStudentIdFromStore = function () {
		return chrome.storage.sync.get(HASHED_STUDENT_ID_DATASTORE_KEY).then(result => {
			return result[HASHED_STUDENT_ID_DATASTORE_KEY];
		});
	};

	let saveHashedStudentIdToStore = function (hashedStudentId) {
		// Some old browsers return undefined instead of Promise... so we return an empty one if that happens.
		return chrome.storage.sync.set({[HASHED_STUDENT_ID_DATASTORE_KEY]: hashedStudentId}) || Promise.resolve();
	};

	// Public
	return {
		readHashedStudentIdFromStore: readHashedStudentIdFromStore,
		saveHashedStudentIdToStore: saveHashedStudentIdToStore,
	};
};
if (!window.UtnBaHelper) window.UtnBaHelper = {};
UtnBaHelper.DataCollector = function (store, pagesDataParser, apiConnector) {

	const LOCAL_STORAGE_DATA_COLLECTOR_KEY = "UtnBaHelper.DataCollector";

	const ONE_DAY_MS = 24 * 60 * 60 * 1000;

	let hashedStudentId;
	let getHashedStudentId = function () {
		if (hashedStudentId) {
			return Promise.resolve(hashedStudentId);
		}
		return pagesDataParser.getStudentId().then(studentId => {
			hashedStudentId = hashCode(studentId);
			return hashedStudentId;
		});
	};

	/**
	 * Sends the user stat with the hashed student it to keep data anonymous.
	 */
	let logUserStat = function (pesoAcademico, passingGradesAverage, allGradesAverage, passingGradesCount, failingGradesCount) {
		return getHashedStudentId().then(hashedStudentId => {
			return apiConnector.logUserStat(hashedStudentId, pesoAcademico, passingGradesAverage, allGradesAverage, passingGradesCount, failingGradesCount);
		});
	};

	/**
	 * Collects, every one day or more, background data such as:
	 * - class schedules and professors
	 * @returns {Promise<void>}
	 */
	let collectBackgroundDataIfNeeded = function () {
		return getHashedStudentId().then(hashedStudentId => {
			// Save hashedStudentId to local storage, so that it can be used for surveys collection.
			return store.saveHashedStudentIdToStore(hashedStudentId).then(() => hashedStudentId);
		}).then(hashedStudentId => {
			let lastTimeCollected = getLastTimeCollectedForStudentId(hashedStudentId);

			let collectMethods = [
				{
					key: "schedules",
					minTime: ONE_DAY_MS,
					method: () => collectClassSchedulesWithProfessors(),
				},
				{
					key: "planCourses",
					minTime: ONE_DAY_MS * 180,
					method: () => collectStudentPlanCourses(),
				}
			];

			let shouldSaveLastTimeCollected = false;
			let promise = Promise.resolve();
			collectMethods.filter(collectMethod => {
				// Never collected or min time has passed.
				return !lastTimeCollected[collectMethod.key] || Date.now() - lastTimeCollected[collectMethod.key] > collectMethod.minTime;
			}).forEach(collectMethod => {
				promise = promise.then(() => {
					return collectMethod.method();
				}).then(() => {
					// If at least one collect method is executed, we need to save the last time collected info to local storage.
					shouldSaveLastTimeCollected = true;
					lastTimeCollected[collectMethod.key] = Date.now();
				});
			});

			return promise.then(() => {
				if (shouldSaveLastTimeCollected) {
					saveLastTimeCollected(hashedStudentId, lastTimeCollected);
				}
			});
		});
	};

	let collectClassSchedulesWithProfessors = function () {
		return Promise.all([
			pagesDataParser.getClassSchedules(),
			pagesDataParser.getProfessorClassesFromSurveys(),
		]).then(results => {
			let classSchedules = results[0].concat(results[1]);
			if (classSchedules.length) {
				return apiConnector.postClassSchedules(classSchedules);
			}
		});
	};

	let collectStudentPlanCourses = function () {
		return pagesDataParser.getStudentPlanCourses().then(planCourses => {
			return apiConnector.postCourses(planCourses);
		});
	};

	// -----

	let getLastTimeCollectedByHashedStudentId = function () {
		let lastTimeCollectedByHashedStudentId;
		try {
			// Don't know why, but some cases were failing with json parsing errors... We simply consider those as not present.
			lastTimeCollectedByHashedStudentId = JSON.parse(localStorage.getItem(LOCAL_STORAGE_DATA_COLLECTOR_KEY));
		} catch (e) {
			console.error(`Error parsing localStorage item...`, e);
		}
		if (!lastTimeCollectedByHashedStudentId) {
			lastTimeCollectedByHashedStudentId = {};
			localStorage.setItem(LOCAL_STORAGE_DATA_COLLECTOR_KEY, JSON.stringify(lastTimeCollectedByHashedStudentId));
		}
		return lastTimeCollectedByHashedStudentId;
	};

	let getLastTimeCollectedForStudentId = function (hashedStudentId) {
		return getLastTimeCollectedByHashedStudentId()[hashedStudentId] || {};
	};

	let saveLastTimeCollected = function (hashedStudentId, lastTimeCollected) {
		let lastTimeCollectedByHashedStudentId = getLastTimeCollectedByHashedStudentId();
		lastTimeCollectedByHashedStudentId[hashedStudentId] = lastTimeCollected;
		localStorage.setItem(LOCAL_STORAGE_DATA_COLLECTOR_KEY, JSON.stringify(lastTimeCollectedByHashedStudentId));
	};

	// Used to make the studentId anonymous.
	let hashCode = function (str) {
		let hash = 0;
		for (let i = 0; i < str.length; i++) {
			hash = ((hash << 5) - hash) + str.charCodeAt(i);
			hash = hash & hash; // Convert to 32bit integer
		}
		return hash;
	};

	// Public
	return {
		getHashedStudentId: getHashedStudentId,
		logUserStat: logUserStat,
		collectBackgroundDataIfNeeded: collectBackgroundDataIfNeeded,
	};
};
// noinspection JSNonASCIINames

if (!window.UtnBaHelper) window.UtnBaHelper = {};
UtnBaHelper.PagesDataParser = function (utils) {

	// We want to fetch only once each page.
	let RESPONSES_CACHE = {};

	let fetchAjaxPOSTContents = function (url, body, useCache = true) {
		return fetchAjaxContents(url, {
			"headers": {
				"X-Requested-With": "XMLHttpRequest", // This is needed so that guarani's server returns a json payload
				"Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
			},
			"method": "POST",
			"body": body,
		}, useCache);
	};
	let fetchAjaxGETContents = function (url, useCache = true) {
		return fetchAjaxContents(url, {
			"headers": {
				"X-Requested-With": "XMLHttpRequest", // This is needed so that guarani's server returns a json payload
			}
		}, useCache);
	};

	/**
	 * Fetches and parses the way guarani's page ajax contents are loaded.
	 */
	let fetchAjaxContents = function (url, fetchOpts, useCache = true) {
		let cacheKey = `${fetchOpts.method || "GET"}:${url}:${fetchOpts.body || ""}`;
		if (useCache && RESPONSES_CACHE[cacheKey]) {
			return Promise.resolve(RESPONSES_CACHE[cacheKey]);
		}

		return fetch(url, fetchOpts).catch(e => {
			throw utils.wrapError(`Error on fetchAjaxContents for ${cacheKey}`, e);
		}).then(response => {
			if (response.status === 429) {
				console.warn(`Got 429 for ${cacheKey}, retrying in 1 second...`);
				return Promise.resolve().then(utils.delay(1000)).then(() => {
					return fetchAjaxContents(url, fetchOpts, useCache);
				});
			}
			return response.json();
		}).then(response => {
			if (response.cod === "1" && response.titulo === "Grado - Acceso" && response.operacion === "acceso") throw new LoggedOutError();
			if (response.cod === "-2" && response.cont.url.includes("/autogestion/grado/acceso/login")) throw new LoggedOutError();
			if (response.cod === "-2" && response.cont.url.includes("/autogestion/grado/inicio_alumno")) throw new RedirectedToHomeError();
			if (response.cod === "-1" && response.cont === "error") throw new GuaraniBackendError(response);
			if (response.cod !== "1") throw new Error(`Invalid ajax contents for url ${cacheKey}. response: ${JSON.stringify(response)}`);
			return response;
		}).then(contents => {
			RESPONSES_CACHE[cacheKey] = contents;
			return contents;
		});
	};

	/**
	 * Some pages that are requested via ajax return responses that contain an array of items to be
	 * rendered in the UI, which are different script tags that contain the html, so they need to be parsed.
	 * This method parses that and returns only the item that is requested (infoId)
	 * @param responseContents the "cont" object of the ajax call.
	 * @param infoId the infoId to filter the elements out.
	 */
	let parseAjaxPageRenderer = function (responseContents, infoId) {
		let renderData = $(responseContents).filter("script").toArray()
			.map(script => $(script).html())
			.filter(script => script.startsWith("kernel.renderer.on_arrival"))
			.map(script => JSON.parse(script.replace("kernel.renderer.on_arrival(", "").replace(");", "")))
			.filter(data => data.info.id === infoId);
		if (renderData.length !== 1) throw new Error(`Found unexpected number of renderers: ${renderData.length} for infoId: ${infoId}. response: ${JSON.stringify(responseContents)}`);
		return renderData[0];
	};

	/**
	 * Fetches an url that returns a XLS and returns the parsed workbook
	 * @param url url that returns a XLS.
	 * @returns {Promise<{}>}
	 */
	let fetchXlsContents = function (url) {
		if (RESPONSES_CACHE[url]) {
			return Promise.resolve(RESPONSES_CACHE[url]);
		}
		return fetch(url).then(response => {
			return response.arrayBuffer();
		}).catch(e => {
			throw utils.wrapError(`Error on fetchXlsContents for ${url}`, e);
		}).then(response => {
			let uint8Array = new Uint8Array(response);
			return Promise.resolve().then(() => XLSX.read(uint8Array), {type: "array"}).catch(e => {
				throw utils.wrapError(`Error on XLSX.read for ${url}. uint8Array: [${uint8Array}].`, e);
			});
		}).then(contents => {
			RESPONSES_CACHE[url] = contents;
			return contents;
		});
	};

	// --------------------

	/**
	 * Tries to resolve and return the student id for the current logged-in user.
	 * @returns {Promise<String>}
	 */
	let getStudentId = function () {
		let studentId = $(".legajo-container .legajo-numero").text().trim();
		if (studentId[studentId.length - 2] !== "-" || studentId[studentId.length - 6] !== ".") throw new Error(`Invalid studentId: ${studentId}`);
		return Promise.resolve(studentId);
	};

	/**
	 * Fetches, from the "Agenda" page, the current classes that the student is taking.
	 * Used to collect the classSchedules
	 * @returns {Promise<Array<{}>>} array of objects for each class, that contains the schedule for it.
	 */
	let getClassSchedules = function () {
		return fetchAjaxGETContents("/autogestion/grado/calendario").then(responseContents => {
			let renderData = parseAjaxPageRenderer(responseContents.cont, "agenda_utn");
			return renderData.info.agenda.cursadas.map(cursadaId => {
				let classData = renderData.info.agenda.comisiones[cursadaId];
				return mapClassDataToClassSchedule(classData);
			});
		}).catch(e => {
			if (e instanceof RedirectedToHomeError) {
				// This happens when students are in the process to register to new schedules,
				// and there is a time window in which class schedules page cannot be seen.
				return [];
			}
			throw e;
		});
	};

	/**
	 * The student's current plan code as shown in the /autogestion/grado/plan_estudio page.
	 * @returns {Promise<string>}
	 */
	let getStudentPlanCode = function () {
		return fetchAjaxGETContents("/autogestion/grado/plan_estudio").then(responseContents => {
			let responseText = parseAjaxPageRenderer(responseContents.cont, "info_plan").content;
			let planText = $(responseText).filter(".encabezado").find("td:eq(1)").text();
			let groups = /^Plan: \((\w+)\)/.exec(planText);
			if (!groups) throw new Error(`planText couldn't be parsed: ${planText}`);
			return groups[1];
		});
	};


	/**
	 * Parses and returns all the courses for the currently selected student's plan.
	 * @returns {Promise<[{planCode: string, level: number, courseCode: string, courseName: string, elective: boolean, dependencies: [{kind: string, requirement: string, courseCode: string}]}]>}
	 */
	let getStudentPlanCourses = function () {
		const levelsMapping = {
			"módulo: primer nivel": 1,
			"módulo: segundo nivel": 2,
			"módulo: tercer nivel": 3,
			"módulo: cuarto nivel": 4,
			"módulo: quinto nivel": 5,
			"módulo: sexto nivel": 6,
			"módulo: sexto año": 6,
			// If we enable this, we also need to resolve how to parse and consider dependencies with "Opción 2"
			"módulo: cuarto analista": -1,
		};
		const kindsMapping = {
			"Para cursar": "REGISTER",
			"Para aprobar": "TAKE_FINAL_EXAM",
		};
		const requirementMapping = {
			"Regularizada": "SIGNED",
			"Regularizada o Cur. Simultánea": "SIGNED",
			"Cursada Simultánea": "SIGNED",
			"Aprobada": "PASSED",
		};

		let getDependencies = (courseCode, dependenciesBtn) => {
			let dependencies = [
				{
					// Add its own dependency (has to be signed in order to take final exam).
					kind: "TAKE_FINAL_EXAM",
					requirement: "SIGNED",
					courseCode: courseCode,
				}
			];

			if (!dependenciesBtn) return Promise.resolve(dependencies);
			let body = `elemento=${dependenciesBtn.getAttribute("data-elemento")}&elemento_padre=${dependenciesBtn.getAttribute("data-elemento-padre")}`;
			return fetchAjaxPOSTContents("https://guarani.frba.utn.edu.ar/autogestion/grado/plan_estudio/correlativas", body).then(response => {
				let $response = $(response.cont).filter(".td-table-correlativas");
				if ($response.find(".alert").text().trim() === "No hay definidas correlativas para la actividad") return dependencies;

				let elems = $response.children().toArray();
				let i = 0;
				while (i < elems.length) {
					// There are 4 type elements per each kind:
					// 1. div with h3 that tells the kind
					// 2. div.alert_verificar_correlativas that is used to verify dependencies (not used here)
					// There could be N of these 2:
					// 		3. h4 that represents one option (right now we expect to only have "Opción 1")
					// 		4. table.table-correlativas with dependencies

					// 1. div with h3 that tells the kind
					let kindTxt = $(elems[i++]).find("> div > h3").text();
					let kind = kindsMapping[kindTxt];
					if (!kind) throw new Error(`Invalid kind ${kindTxt}. responseCont: ${response.cont}`);

					// 2. div.alert_verificar_correlativas that is used to verify dependencies (not used here)
					if (!$(elems[i++]).hasClass("alert_verificar_correlativas")) throw new Error(`Found invalid div in second position. responseCont: ${response.cont}`);

					while (i < elems.length && $(elems[i]).filter("h4").length) {
						// 3. h4 that represents one option (right now we expect to only have "Opción 1")
						let option = $(elems[i++]).filter("h4").text();
						if (option !== "Opción 1") {
							// For now, we only handle "Opción 1"... TODO: Eventually we should support all of them:
							i++;
							continue;
						}

						// 4. table.table-correlativas with dependencies
						$(elems[i++]).filter("table.table-correlativas").find("tr:not(:first)").toArray().forEach(tr => {
							let $tr = $(tr);

							// Some new rows have the following texts: 'Módulo: Maquinas Alternativas y Turbomáquinas'	'Tener 1 actividades aprobadas'
							// TODO for now we are ignoring these, eventually we should support them.
							let dependencyCourse = $tr.find("td:eq(0)").text().trim();
							if (dependencyCourse.startsWith("Módulo: ")) return;

							let groups = /^(.*) \((\d{6})\)$/.exec(dependencyCourse);
							if (!groups) throw new Error(`dependencyCourse couldn't be parsed: ${dependencyCourse}. responseCont: ${response.cont}`);
							// let courseName = groups[1];
							let dependencyCourseCode = groups[2];

							let requirementTxt = $tr.find("td:eq(1)").text().trim();
							let requirement = requirementMapping[requirementTxt];
							if (!requirement) throw new Error(`requirementTxt couldn't be parsed: ${requirementTxt}. responseCont: ${response.cont}`);

							dependencies.push({
								kind: kind,
								requirement: requirement,
								courseCode: dependencyCourseCode,
							});
						});
					}
				}
				return dependencies;
			});
		};

		return fetchAjaxGETContents("/autogestion/grado/plan_estudio").then(responseContents => {
			let responseText = parseAjaxPageRenderer(responseContents.cont, "info_plan").content;
			// Need to wrap contents into parent div as many elements come as first level, and we cannot use find() then.
			let $contents = $(`<div id="info_plan">${responseText}</div>`);

			// PlanCode
			let planText = $contents.find(".encabezado").find("td:eq(1)").text();
			let groups = /^Plan: \((\w+)\)/.exec(planText);
			if (!groups) throw new Error(`planText couldn't be parsed: ${planText}. responseText: ${responseText}`);
			let planCode = groups[1];

			// Courses, cannot do it in parallel as the server returns a lot of 429s.
			let courses = [];
			let maxLevel = -1;
			let promise = Promise.resolve();
			$contents.find(".accordion").toArray().forEach(accordion => {
				let $accordion = $(accordion);
				let $accordionHeading = $accordion.find("> .accordion-group > .accordion-heading a");
				let areElectives = $accordionHeading.hasClass("materia_generica") || $accordionHeading.text().toLowerCase().includes("electivas");

				// The table could be within a level, so we try to grab it from there first.
				let $parentAccordion = $accordion.parent().closest(".accordion");
				if ($parentAccordion.length) {
					$accordionHeading = $parentAccordion.find("> .accordion-group > .accordion-heading a");
				}
				let levelText = $accordionHeading.text().trim().toLowerCase();
				let level = levelsMapping[levelText];
				// If level couldn't be matched, but this is an accordion of electives and is a first level accordion,
				// then it means they are the electives of the entire plan, and should be considered as part of the last level.
				if (typeof level === "undefined" && areElectives && $parentAccordion.length === 0) level = maxLevel;
				if (typeof level === "undefined") throw new Error(`Invalid levelText: '${levelText}'. responseText: ${responseText}`);
				if (level === -1) return [];
				maxLevel = Math.max(maxLevel, level);

				return $accordion.find("table:first tbody tr:not(.correlatividades)").toArray().forEach(courseRow => {
					let courseText = courseRow.querySelector("td").innerText.trim();
					let groups = /(.*) \((\d{6})\)/.exec(courseText);
					if (!groups) throw new Error(`courseText couldn't be parsed: ${courseText}. responseText: ${responseText}`);
					let courseName = groups[1];
					let courseCode = groups[2];

					// Dependencies btn:
					let dependenciesBtn = courseRow.lastChild.querySelector(".ver_correlatividades");
					promise = promise.then(() => {
						return getDependencies(courseCode, dependenciesBtn)
					}).then(dependencies => {
						courses.push({
							planCode: planCode,
							level: level,
							courseCode: courseCode,
							courseName: courseName,
							elective: areElectives,
							dependencies: dependencies,
						});
					});
				});
			});

			return promise.then(() => {
				return courses;
			});
		});
	};

	/**
	 * Parses and returns all the student's academic history. Includes courses and final exams (both passed and failed)
	 * @returns {Promise<{courses: [{courseCode: string, isPassed: boolean, grade: number, weightedGrade: number, date: Date}], finalExams: [{courseCode: string, isPassed: boolean, grade: number, weightedGrade: number, date: Date}]}>}
	 */
	let getCoursesHistory = function () {
		let courses = [];
		let finalExams = [];
		// Use a map to also validate returned types.
		let arrayByTypes = {
			"En curso": courses,
			"Regularidad": courses,
			"Promocion": finalExams,
			"Examen": finalExams,
			"Equivalencia": finalExams,
		};
		const gradeIsPassedTypes = {
			"Promocionado": true,
			"Aprobado": true,
			"Reprobado": false,
			"Ausente": false,
		};
		return fetchXlsContents("/autogestion/grado/historia_academica/exportar_xls/?checks=PromocionA,RegularidadA,RegularidadR,RegularidadU,EnCurso,ExamenA,ExamenR,ExamenU,EquivalenciaA,EquivalenciaR,AprobResA,CreditosA,&modo=anio&param_modo=").then(workbook => {
			let sheet = workbook.Sheets["Reporte"];
			if (!sheet) throw new Error(`Workbook does not contain sheet. Sheetnames: ${workbook.SheetNames}`);

			// First 5 rows do not include important data:
			if (sheet.A6.v !== "Fecha") throw new Error(`Invalid sheet data: ${JSON.stringify(XLSX.utils.sheet_to_json(sheet))}`);
			sheet["!ref"] = sheet["!ref"].replace("A1:", "A6:");

			XLSX.utils.sheet_to_json(sheet).forEach(row => {
				let date = parseDate(row["Fecha"]);
				let courseText = row["Actividad"];
				let type = row["Tipo"];
				let gradeText = row["Nota"];
				let gradeIsPassedText = row["Resultado"];

				if (!gradeText || !gradeIsPassedText) return; // Ignore non finished items

				let groups = /(.*) \((\d{6})\)/.exec(courseText);
				if (!groups) throw new Error(`courseText couldn't be parsed: ${courseText}. Row: ${JSON.stringify(row)}`);
				let courseCode = groups[2];

				let arr = arrayByTypes[type];
				if (!arr) throw new Error(`Type not handled: ${type}. Row: ${JSON.stringify(row)}`);

				let grade = parseInt(gradeText) || null;
				let weightedGrade = grade !== null ? getWeightedGrade(date, grade) : null;

				if (typeof gradeIsPassedTypes[gradeIsPassedText] === "undefined") throw new Error(`gradeIsPassedText couldn't be parsed: ${gradeIsPassedText}. Row: ${JSON.stringify(row)}`);
				let isPassed = gradeIsPassedTypes[gradeIsPassedText];

				arr.push({
					courseCode: courseCode,
					isPassed: isPassed,
					grade: grade,
					weightedGrade: weightedGrade,
					date: date,
				});
			});
			return {
				courses: courses,
				finalExams: finalExams,
			};
		});
	};

	/**
	 * Fetches all the current surveys that the user has to take (cannot retrieve the ones that have already been taken)
	 * For each of them resolves the current professor name, class, course, quarter, etc.
	 * @returns {Promise<*[]>} an array of class schedules for each combination of professor and class
	 */
	let getProfessorClassesFromSurveys = function () {
		return fetchAjaxGETContents("/autogestion/grado/inicio_alumno").then(responseContents => {
			let surveysResponseText = parseAjaxPageRenderer(responseContents.cont, "lista_encuestas_pendientes").content;

			let promises = $(surveysResponseText).find("ul li a").toArray()
				.map(a => a.href)
				.map(siuUrl => {
					return fetchAjaxGETContents(siuUrl).then(siuResponseText => {
						// Return the kollaUrl
						return $(siuResponseText.cont).find("iframe").get(0).src;
					});
				});
			return Promise.all(promises).then(kollaUrls => kollaUrls.flat());
		}).then(kollaUrls => {
			let promises = kollaUrls.map(kollaUrl => {
				return utils.backgroundFetch({url: kollaUrl}).then(kollaResponseText => {
					let surveysMetadata = parseKollaSurveyForm($(kollaResponseText), kollaResponseText);

					// We could eventually merge same class professors, but the backend still accepts this:
					return surveysMetadata.map(surveyMetadata => {
						return {
							year: surveyMetadata.year,
							quarter: surveyMetadata.quarter,
							classCode: surveyMetadata.classCode,
							courseCode: surveyMetadata.courseCode,
							professors: [
								{
									name: surveyMetadata.professorName,
									kind: surveyMetadata.surveyKind,
									role: surveyMetadata.professorRole,
								}
							]
						};
					});
				});
			});
			return Promise.all(promises).then(surveys => surveys.flat());
		});
	};

	// --------------------

	// Parses a date with format DD/MM/YYYY
	let parseDate = function (dateStr) {
		let dateParts = dateStr.split("/");
		return new Date(dateParts[2], dateParts[1] - 1, dateParts[0]);
	};

	let getWeightedGrade = function (date, grade) {
		if (date < UtnBaHelper.Consts.NEW_GRADES_REGULATION_DATE) {
			return UtnBaHelper.Consts.WEIGHTED_GRADES[grade];
		} else {
			return grade;
		}
	};

	/**
	 * Parses a period with the form `Grado Primer Cuatrimestre 2022` into an object that contains the year and quarter.
	 * @param periodTxt
	 * @returns {{year: number, quarter: string}}
	 */
	let parsePeriodTxt = function (periodTxt) {
		if (periodTxt.startsWith("Escuela de Verano")) {
			// Handle specific case for "Escuela de Verano", e.g. "Escuela de Verano 2023 - CL2022"
			const yearRegex = new RegExp(`^Escuela de Verano \\d{4} - CL(\\d{4})$`);
			let groups = yearRegex.exec(periodTxt);
			if (!groups) throw new Error(`Class period couldn't be parsed: ${periodTxt}`);
			let year = parseInt(groups[1]);
			return {
				year: year,
				quarter: "VERANO",
			};
		}
		const quarterTxtMapping = {
			"Anual": "A",
			"Primer Cuatrimestre": "1C",
			"Segundo Cuatrimestre": "2C",
			// Weird cases, was found in "Grado ASS 2022", and "Grado SyS 2024" (seems to be specific to courseCode: 950454 -> "Análisis de Señales y Sistemas")
			"ASS": "A",
			"SyS": "A",
		};
		const yearAndQuarterRegex = new RegExp(`^Grado (${Object.keys(quarterTxtMapping).join("|")}) (\\d{4})$`);
		let groups = yearAndQuarterRegex.exec(periodTxt);
		if (!groups) throw new Error(`Class period couldn't be parsed: ${periodTxt}`);
		let quarter = quarterTxtMapping[groups[1]];
		let year = parseInt(groups[2]);
		return {
			year: year,
			quarter: quarter,
		};
	};

	let parseBranchTxt = function (branchTxt) {
		const branchTxtMapping = {
			"Sede Medrano": "MEDRANO",
			"Sede Campus": "CAMPUS",
			"Medrano / Campus": "MEDRANO_CAMPUS",
			"Virtual": "AULA_VIRTUAL",
			"Escuela Técnica - Piñero": "PIÑERO",
		};
		let branch = branchTxtMapping[branchTxt];
		if (!branch) throw new Error(`Branch txt couldn't be parsed: ${branchTxt}`);
		return branch;
	};

	/**
	 * New (or different) version of the schedules, represented in the form of:
	 * [
	 * 		{dia_semana: "Lunes", hora_catedra_inicio: "16", hora_catedra_fin: "19"},
	 * 		{dia_semana: "Jueves", hora_catedra_inicio: "16", hora_catedra_fin: "19"}
	 * ]
	 * @param arr the schedule received from the classData struct (guarani's server)
	 * @returns {{day: string, shift: string, firstHour: number, lastHour: number}[]}
	 */
	let parseSchedulesFromArray = function (arr) {
		return arr.map(schedule => {
			let day = Object.entries(UtnBaHelper.Consts.DAYS).filter(entry => entry[1] === schedule.dia_semana).map(entry => entry[0])[0];
			if (!day) throw new Error(`Couldn't parse day: ${schedule.dia_semana}`);

			let shiftIdx = Math.floor((parseInt(schedule.hora_catedra_inicio) - 1) / 7); // 0:MORNING, 1:AFTERNOON, 2:NIGHT
			let shift = Object.keys(UtnBaHelper.Consts.HOURS)[shiftIdx];
			let firstHour = (parseInt(schedule.hora_catedra_inicio) - 1) % 7;
			let lastHour = (parseInt(schedule.hora_catedra_fin) - 1) % 7;
			return {
				day: day,
				shift: shift,
				firstHour: firstHour,
				lastHour: lastHour,
			};
		});
	};


	let mapClassDataToClassSchedule = function (classData) {
		try {
			let period = parsePeriodTxt(classData.periodo_nombre);
			let branch = parseBranchTxt(classData.ubicacion_nombre);
			let schedules = parseSchedulesFromArray(classData.horas_catedra);
			return {
				year: period.year,
				quarter: period.quarter,
				classCode: classData.comision_nombre.toUpperCase().replace(" - TUTORÍA", ""),
				courseCode: classData.actividad_codigo,
				// courseName is not used right now.
				// The backend does not accept this for posts (class schedules or previous professors),
				// so if we decide to add it, we should remove it from api calls.
				// courseName: classData.actividad_nombre,
				branch: branch,
				schedules: schedules,
			};
		} catch (e) {
			throw utils.wrapError(`Couldn't parse classData: ${JSON.stringify(classData)}`, e);
		}
	}

	/**
	 * Parses the responseText of the Kolla forms, and returns the survey form data along with the answers.
	 * @returns {[{surveyKind: string, professorRole: string, classCode: string, year: number, courseCode: string, professorName: string, quarter: string, surveyFieldValues: []}]}
	 */
	let parseKollaSurveyForm = function ($kollaResponseText, htmlForLog) {
		const surveyKindsMapping = {
			"DOCENTE": "DOCENTE",
			"AUXILIARES DOCENTES": "AUXILIAR",
			"DOCENTES AUXILIARES": "AUXILIAR",
		};
		const quarterMapping = {
			"ANUAL": "A",
			"PRIMER CUATRIMESTRE": "1C",
			"SEGUNDO CUATRIMESTRE": "2C",
			"ASS": "A", // Weird case, was found in "ENCUESTA DOCENTES AUXILIARES ASS 2022"
		};
		const surveyTitleRegex = new RegExp(`^ENCUESTA (${Object.keys(surveyKindsMapping).join("|")}) (${Object.keys(quarterMapping).join("|")}) (\\d{4})$`);

		const professorRolesMapping = {
			"Titular": "TITULAR",
			"Asociado": "ASOCIADO",
			"Adjunto": "ADJUNTO",

			"JTP": "JEFE DE TP",
			"Ayudante de 1ra": "AYUDANTE 1RA",
			"Ayudante de 2da": "AYUDANTE 2DA",
		};
		const professorRegex = new RegExp(`^(.*) \\((${Object.keys(professorRolesMapping).join("|")})(?: \\(Responsable de Cátedra\\))?\\)$`);

		// Sometimes the survey is already completed, and it looks like there are 2 types of HTML that represent this
		// first one looks to be when completing at the moment, and second when opening a completed one, which shouldn't
		// really happen as we are only grabbing the pending ones (or forms being completed) but from time to time
		// we get some errors, so we can ignore these. The alert box may contain the following messages:
		// 1. `La encuesta 'Probabilidad y Estadística (950704) - Comisión: Z2017' ya ha sido respondida.`
		// 2. `Gracias por completar la encuesta. Por favor descargá y guardá el comprobante generado. Los códigos allí incluídos se generaron por única vez y serán requeridos si solicitas consultar las respuestas.`
		let alertBoxText = $kollaResponseText.find(".alert.alert-success").text().trim();
		if (alertBoxText.includes(" ya ha sido respondida.") ||
			alertBoxText.includes("Gracias por completar la encuesta")) return [];

		// Replace is for cases like 'Inglés Técnico Nivel I (951602) - Comisión: Z2498 - TUTORÍA'
		let courseTitle = $kollaResponseText.find(".formulario-titulo").text().replace(" - TUTORÍA", ""); // E.g.: 'Simulación (082041) - Comisión: K4053', 'Administración Gerencial (082039) - Comisión: K5054'
		let groups = /^(.*) \((\d{6})\) - Comisión: ([\w\d]{5})$/.exec(courseTitle);
		if (!groups) throw new Error(`Survey courseTitle couldn't be parsed: ${courseTitle}. HTML: ${htmlForLog}`);
		// let courseName = groups[1]; // E.g. Simulación
		let courseCode = groups[2]; // E.g. 082041
		let classCode = groups[3]; // E.g. K4053

		return $kollaResponseText.find(".encuesta").toArray().map(surveyDiv => {
			let $surveyDiv = $(surveyDiv);

			let surveyTitle = $surveyDiv.find(".encuesta-titulo");
			surveyTitle = surveyTitle.text().trim();

			groups = surveyTitleRegex.exec(surveyTitle);
			if (!groups) throw new Error(`surveyTitle couldn't be parsed: ${surveyTitle}. HTML: ${htmlForLog}`);

			let surveyKind = surveyKindsMapping[groups[1]]; // DOCENTE, AUXILIAR
			let quarter = quarterMapping[groups[2]]; // A, 1C, 2C
			let year = parseInt(groups[3]); // 2018, 2019, ...

			let professor = $surveyDiv.find(".encuesta-elemento h3");
			professor = professor.text().trim();

			groups = professorRegex.exec(professor);
			if (!groups) throw new Error(`professor couldn't be parsed: ${professor}. HTML: ${htmlForLog}`);

			let professorName = groups[1].toUpperCase();
			let professorRole = professorRolesMapping[groups[2]]; // TITULAR, ASOCIADO, ADJUNTO, etc.

			let surveyFieldValues = $surveyDiv.find(".panel-info .panel-body .form-group").toArray()
				.map(item => {
					let $item = $(item);
					let $questionLabel = $item.find("> label");

					let question = $questionLabel.text().replace("*", "").trim();
					let value = null;

					let labelFor = $questionLabel.attr("for");
					let $answerElement = $item.find(`[name=${labelFor}]`);
					if ($answerElement.is("textarea")) {
						value = $answerElement.val() || null;
					} else if ($answerElement.is("input")) {
						value = parseInt($answerElement.filter(":checked").parent().text());
						value = isNaN(value) ? null : value;
					} else {
						throw new Error(`Couldn't parse value for question ${question}. Item: ${$item.html()}`);
					}
					return {
						question: question,
						value: value,
					};
				});

			return {
				surveyKind: surveyKind,
				year: year,
				quarter: quarter,
				classCode: classCode,
				courseCode: courseCode,
				professorName: professorName,
				professorRole: professorRole,

				surveyFieldValues: surveyFieldValues, // Only used for posting surveys, not professor classes.
			};
		});
	};

	// Public
	return {
		fetchAjaxGETContents: fetchAjaxGETContents,

		// --

		getStudentId: getStudentId,
		getClassSchedules: getClassSchedules,

		getStudentPlanCode: getStudentPlanCode,
		getStudentPlanCourses: getStudentPlanCourses,
		getCoursesHistory: getCoursesHistory,

		getProfessorClassesFromSurveys: getProfessorClassesFromSurveys,

		// Exposed parsers / mappers
		parseKollaSurveyForm: parseKollaSurveyForm,
		mapClassDataToClassSchedule: mapClassDataToClassSchedule,
	};
};
if (!window.UtnBaHelper) window.UtnBaHelper = {};
UtnBaHelper.HorariosPage = function () {

	let trimCourseName = function (name) {
		name = name.trim();
		if (name.length > 20) {
			return name.substring(0, 20) + "...";
		} else {
			return name;
		}
	};

	let getColorFromClass = function (className) {
		const colorRegex = /materia-color-(\d*)/;
		let groups = colorRegex.exec(className);
		if (!groups) return null;
		return groups[1];
	};

	let getClassesByColor = function () {
		let classesByColor = {};
		$(".cursada .cursada-header").each(function () {
			let name = $(this).find("h4").text().trim();
			let color = getColorFromClass($(this).find(".cuadrado").attr("class"));
			if (!name || !color) return;
			classesByColor[color] = name;
		});
		return classesByColor;
	};

	let setCourseNamesInTable = function () {
		let classesByColor = getClassesByColor();
		let last = null;
		$(".agenda-hora").each(function () {
			let color = getColorFromClass($(this).attr("class"));
			if (color && last !== color && classesByColor[color]) {
				$(this).text(trimCourseName(classesByColor[color]));
				$(this).addClass("name-container");
			}
			last = color;
		});
	};


	return {
		init: function () {
			return Promise.resolve().then(() => {
				setCourseNamesInTable();
			});
		},
		close: function () {
		},
	};
};
if (!window.UtnBaHelper) window.UtnBaHelper = {};

const textChild = document.createTextNode(" o haciendo click ")
const redirectLink = document.createElement('a')
redirectLink.href = "/autogestion/grado/datos_censales"
redirectLink.textContent = "AQUÍ"

UtnBaHelper.InscripcionAExamenesPage = function () {


    const errorMessageSelector = document.querySelector('#lista_materias > div.alert.info.strong')

    function replaceMessageIfExists() {
        if (errorMessageSelector) {
            errorMessageSelector.appendChild(textChild)
            errorMessageSelector.appendChild(redirectLink)
        }
    }


    return {
        init: function () {
            return Promise.resolve().then(() => {
                replaceMessageIfExists();
            });
        },
        close: function () {
        },
    };
};
if (!window.UtnBaHelper) window.UtnBaHelper = {};
UtnBaHelper.PreInscripcionPage = function (pagesDataParser, utils, apiConnector) {

	let addPreviousProfessorsTable = function () {
		return Promise.resolve().then(() => {
			return fetchCourseAlternatives();
		}).then(courseOptionsData => {
			return renderPreviousProfessorsTable(courseOptionsData);
		});
	};

	let fetchCourseAlternatives = function () {
		return Promise.resolve().then(() => {
			// Avoid using cache as the endpoint is always the same but the student may register or unregister from the course.
			return pagesDataParser.fetchAjaxGETContents(location.href, false);
		}).then(response => {
			// `comisiones` may include the current class schedules. This is not a problem because we access the array by id.
			// But we could eventually filter them out by using the `cursadas` array if we confirm it
			return response.agenda.comisiones;
		});
	};

	let renderPreviousProfessorsTable = function (courseOptionsData) {
		let optionId = 0;
		let optionDetails = [];
		let previousProfessorsRequest = $("#comision option").toArray()
			.map(option => {
				let $option = $(option);
				let classData = courseOptionsData[$option.val()];
				if (!classData) return null;

				// Set a optionId in the option text to identify in the table that is added later.
				optionId++;
				optionDetails.push($option.text());
				$option.text(`(${optionId})` + $option.text());

				return pagesDataParser.mapClassDataToClassSchedule(classData);
			})
			.filter(req => !!req);

		// Returns a List that corresponds one to one with the request list, with maps that represent: year -> classCode (the new one) -> List of professors
		return apiConnector.getPreviousProfessors(previousProfessorsRequest).then(response => {
			$("#insc_alternativas .inscripcion-alternativa").before(`
				<div class="utnba-helper">
					<div class="alert info">
						<h3 style="text-align: center;">UTN.BA HELPER - Información importante</h3>
						<p><b>La informacion sobre profesores anteriores es provista por el "UTN.BA Helper" y no es parte del sistema de la UTN.</b></p>
						<p>La intencion de esta tabla es, en base a datos colectados por el "UTN.BA Helper", intentar predecir que profesor va a estar en cada cursada, basandonos en los profesores que estuvieron en cursadas anteriores.
						<p>Para cada horario presentado en el combo de abajo, se muestra un item en la tabla, que puede ser identificado por el ID que es agregado al texto de cada opcion, y que es mostrado en cada fila de la tabla.</p>
					</div>
					<table><tbody><tr><th>ID</th><th>Detalle</th><th>Profesores en años anteriores</th></tr></tbody></table>
					<hr>
				</div>
			`);
			let $tbody = $("#insc_alternativas .utnba-helper tbody");

			for (let i = 0; i < response.length; i++) {
				let previousProfessors = response[i];
				optionId = i + 1;

				let content = `<ul class="no-margin">`;
				Object.entries(previousProfessors)
					.sort((a, b) => (a[0] < b[0] ? 1 : a[0] > b[0] ? -1 : 0))
					.forEach(classesByYear => {
						let year = classesByYear[0];
						content += `<li>${year}<ul class="no-margin">`;
						Object.entries(classesByYear[1])
							.sort((a, b) => (a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0))
							.forEach(professorsByClass => {
								let newClassCode = professorsByClass[0];
								content += `<li>${newClassCode}<ul class="no-margin">`;
								professorsByClass[1].forEach(professor => {
									content += utils.getProfessorLi(professor);
								});
								content += `</ul></li>`;
							});
						content += `</ul></li>`;
					});
				content += `</ul>`;
				let details = optionDetails[i].split("|").map(t => t.trim()).join("<br>");
				$tbody.append(`<tr><td>(${optionId})</td><td>${details}</td><td>${content}</td></tr>`);
			}
		});
	};


	let addPreviousProfessorsTableEventFn;
	return {
		init: function () {
			return Promise.resolve().then(() => {
				// Need to listen to course register changes, as the combo is reloaded, and we need to add the table again.
				// We need to un register them on close, as changing a course will trigger a new PreInscripcionPage.
				// Events triggered from foreground script:
				addPreviousProfessorsTableEventFn = () => utils.runAsync("addPreviousProfessorsTable", addPreviousProfessorsTable);
				window.addEventListener("__utn_ba_event_comision_preinscripta", addPreviousProfessorsTableEventFn);
				window.addEventListener("__utn_ba_event_comision_despreinscripta", addPreviousProfessorsTableEventFn);
				return addPreviousProfessorsTable();
			});
		},
		close: function () {
			window.removeEventListener("__utn_ba_event_comision_preinscripta", addPreviousProfessorsTableEventFn);
			window.removeEventListener("__utn_ba_event_comision_despreinscripta", addPreviousProfessorsTableEventFn);
		},
	};
};
if (!window.UtnBaHelper) window.UtnBaHelper = {};
UtnBaHelper.ProfessorsSearchCustomPage = function ($container, services) {

	const SENTIMENT_COLORS = {
		"POSITIVE": "#19B135",
		"NEUTRAL": "#000000",
		"NEGATIVE": "#D51C26",
	}

	let $searchDiv;
	let $searchResultsDiv;
	let $professorResultsTitleDiv; // Just the title with the professor name.
	let $coursesResultDiv; // Shows the last courses in which the professor was present
	let $surveyResultDiv; // Shows the survey results of the given professor

	let createPage = function () {
		$searchDiv = $("<div></div>");
		$searchDiv.append(`<span style="font-weight: bold;">Buscar docente: </span>`);
		let $searchTxt = $(`<input type="text" style="margin: 0 5px 0 0;" placeholder="Minimo 3 caracteres..." />`);
		$searchTxt.on("keydown", function (e) {
			if (e.key === "Enter") {
				services.utils.runAsync("ProfessorsSearch", () => search($searchTxt.val().trim()));
				return false;
			}
		});
		$searchDiv.append($searchTxt);
		let $searchBtn = $(`<a href="#" class="btn btn-info btn-small">Buscar</a>`);
		$searchBtn.on("click", function () {
			services.utils.runAsync("ProfessorsSearch", () => search($searchTxt.val().trim()));
			return false;
		});
		$searchDiv.append($searchBtn);
		$searchDiv.append("<hr>");
		$container.append($searchDiv);

		$searchResultsDiv = $(`<div></div>`);
		$searchResultsDiv.hide();
		$searchResultsDiv.append("<h2>Resultados de busqueda</h2>");
		let $searchResultsTable = $(`<table></table>`).append("<tbody></tbody>");
		$searchResultsTable.on("click", "a", function () {
			let professorName = $(this).text();
			services.utils.runAsync("retrieveProfessorData", () => retrieveProfessorData(professorName));
			return false;
		});
		$searchResultsDiv.append($searchResultsTable);
		$searchResultsDiv.append("<hr>");
		$container.append($searchResultsDiv);

		$professorResultsTitleDiv = $(`<div></div>`);
		$container.append($professorResultsTitleDiv);
		$coursesResultDiv = $(`<div></div>`);
		$container.append($coursesResultDiv);
		$surveyResultDiv = $(`<div></div>`);
		$container.append($surveyResultDiv);
	};

	let search = function (query) {
		if (query.length < 3) return;
		hideProfessorData();
		$searchResultsDiv.show().get(0).scrollIntoView({behavior: "smooth"});
		$searchResultsDiv.hide();
		return services.apiConnector.searchProfessors(query).then(results => {
			let trs = results.map(item => {
				return `<tr><td><a href="#">${item.value}</a></td><td>${item.data.surveysCount}</td><td>${item.data.classScheduleOccurrences}</td></tr>`;
			}).join("");
			$searchResultsDiv.show();
			$searchResultsDiv.find("table tbody")
				.html(trs)
				.prepend("<tr><th>Profesor</th><th>Cantidad de encuestas (total historico)</th><th>Cantidad de cursos (total historico)</th></tr>");
		});
	};

	let hideProfessorData = function () {
		$professorResultsTitleDiv.hide();
		$coursesResultDiv.hide();
		$surveyResultDiv.hide();
	};

	let retrieveProfessorData = function (professorName) {
		$professorResultsTitleDiv.show().get(0).scrollIntoView({behavior: "smooth"});
		$professorResultsTitleDiv.html(`<h2 style="text-align: center;">Resultados para ${professorName}</h2><hr>`);
		return Promise.all([
			retrieveProfessorCourses(professorName),
			retrieveSurveyResults(professorName),
		]);
	};

	let retrieveProfessorCourses = function (professorName) {
		$coursesResultDiv.hide();
		// For now, we are showing just the latest 20 classes.
		return services.apiConnector.getClassesForProfessor(professorName, 0, 20).then(classSchedules => {
			$coursesResultDiv.html("");
			let trs = classSchedules.map(classSchedule => {
				let professorLis = (classSchedule.professors || []).map(professor => {
					return services.utils.getProfessorLi(professor);
				}).join("");
				return `<tr>
					<td>${classSchedule.year}</td>
					<td>${classSchedule.quarter}</td>
					<td><a class="no-ajax" href="${UtnBaHelper.CustomPages.getCourseResultsUrl(classSchedule.courseCode)}" target="_blank">${classSchedule.courseName}</a></td>
					<td>${classSchedule.classCode}</td>
					<td>${classSchedule.branch || "-"}</td>
					<td>${services.utils.getSchedulesAsString(classSchedule.schedules)}</td>
					<td><ul class="no-margin">${professorLis}</ul></td>
				</tr>`;
			}).join("");
			$coursesResultDiv.append(`
				<h3>Ultimos cursos en los que estuvo presente</h3>
				<table>
					<tbody>
						<tr><th colspan="2">Cuatr.</th><th>Materia</th><th>Curso</th><th>Anexo</th><th>Horario</th><th>Profesores</th></tr>
						${trs}
					</tbody>
				</table>
			`);
			$coursesResultDiv.append(`<hr>`);
			$coursesResultDiv.show();
		});
	};

	let retrieveSurveyResults = function (professorName) {
		$surveyResultDiv.hide();
		return services.apiConnector.getProfessorSurveysAggregate(professorName).then(response => {
			$surveyResultDiv.html("");
			Object.entries(response)
				// Put DOCENTE before AUXILIAR
				.sort((a, b) => (a[0] > b[0] ? -1 : 1))
				.forEach(entry => appendSurveyResults(entry[0], entry[1]));
			$surveyResultDiv.show();
		});
	};

	let appendSurveyResults = function (surveyKind, results) {
		$surveyResultDiv.append(`<h3>Encuesta de tipo ${surveyKind}</h3>`);

		if (results.percentageFields.length) {
			let percentageRows = results.percentageFields.map(item => {
				return `<tr><td>${item.question}</td><td style="background-color: ${services.utils.getColorForAvg(item.average)}">${item.average}</td><td>${item.count}</td></tr>`;
			}).join("");
			$surveyResultDiv.append(`
				<h4>Puntajes</h4>
				<div style="font-weight: bold; margin-bottom: 12px;">General: ${services.utils.getOverallScoreSpan(results.overallScore)}</div>
				<table class="percentage-questions">
					<tbody>
						<tr><th>Pregunta</th><th>Promedio</th><th>Muestra</th></tr>
						${percentageRows}
					</tbody>
				</table>
			`);
		}

		if (results.textFields.length) {
			let textHeaderColumns = results.textFields.map(item => {
				return `<th>${item.question}</th>`;
			}).join("");
			let textValueColumns = results.textFields.map(item => {
				let answers = item.values.map(answer => `<i>"${answer}"</i>`).join(`<hr style="margin: 8px 0;">`);
				return `<td style="color: ${SENTIMENT_COLORS[item.sentiment]}">${answers}</td>`;
			}).join("");
			$surveyResultDiv.append(`
				<h4>Comentarios</h4>
				<table class="text-questions" style="table-layout: fixed; width: 100%;">
					<tbody>
						<tr>${textHeaderColumns}</tr>
						<tr>${textValueColumns}</tr>
					</tbody>
				</table>
			`);
		}
		$surveyResultDiv.append(`<hr>`);
	};


	return {
		init: function () {
			return Promise.resolve().then(() => {
				createPage();
				let professorName = new URLSearchParams(window.location.search).get(UtnBaHelper.ProfessorsSearchCustomPage.customParamKey);
				if (professorName) {
					return retrieveProfessorData(professorName);
				}
			});
		},
		close: function () {
		},
	};
};

UtnBaHelper.ProfessorsSearchCustomPage.menuName = "Buscar docentes";
UtnBaHelper.ProfessorsSearchCustomPage.customParamKey = "professorName";
if (!window.UtnBaHelper) window.UtnBaHelper = {};
UtnBaHelper.CoursesSearchCustomPage = function ($container, services) {

	let $searchDiv;
	let $searchResultsDiv;
	let $courseDataDiv;

	let createPage = function () {
		$searchDiv = $("<div></div>");
		$searchDiv.append(`<span style="font-weight: bold;">Buscar por nombre o código de materia: </span>`);
		let $searchTxt = $(`<input type="text" style="margin: 0 5px 0 0;" placeholder="Minimo 3 caracteres..." />`);
		$searchTxt.on("keydown", function (e) {
			if (e.key === "Enter") {
				services.utils.runAsync("CoursesSearch", () => search($searchTxt.val().trim()));
				return false;
			}
		});
		$searchDiv.append($searchTxt);
		let $searchBtn = $(`<a href="#" class="btn btn-info btn-small">Buscar</a>`);
		$searchBtn.on("click", function () {
			services.utils.runAsync("CoursesSearch", () => search($searchTxt.val().trim()));
			return false;
		});
		$searchDiv.append($searchBtn);
		$searchDiv.append("<hr>");
		$container.append($searchDiv);

		$searchResultsDiv = $(`<div></div>`);
		$searchResultsDiv.hide();
		$searchResultsDiv.append("<h2>Resultados de busqueda</h2>");
		let $searchResultsTable = $(`<table></table>`).append("<tbody></tbody>");
		$searchResultsTable.on("click", "a", function () {
			let courseCode = $(this).text();
			services.utils.runAsync("retrieveClassesForCourse", () => retrieveClassesForCourse(courseCode, 0, 15));
			return false;
		});
		$searchResultsDiv.append($searchResultsTable);
		$searchResultsDiv.append("<hr>");
		$container.append($searchResultsDiv);

		$courseDataDiv = $(`<div></div>`);
		$courseDataDiv.hide();
		$courseDataDiv.append("<h2>Resultados para </h2>");
		let $classesTable = $(`<table></table>`).append("<tbody></tbody>");
		$courseDataDiv.append($classesTable);
		$courseDataDiv.append("<hr>");
		$container.append($courseDataDiv);
	};

	let search = function (query) {
		if (query.length < 3) return;
		$searchResultsDiv.show().get(0).scrollIntoView({behavior: "smooth"});
		$searchResultsDiv.hide();
		$courseDataDiv.hide();
		return services.apiConnector.searchCourses(query).then(results => {
			let trs = results.map(item => {
				return `<tr><td>${item.value}</td><td><a href="#">${item.data}</a></td></tr>`;
			}).join("");
			$searchResultsDiv.show();
			$searchResultsDiv.find("table tbody")
				.html(trs)
				.prepend("<tr><th>Nombre</th><th>Codigo</th></tr>");
		});
	};

	/** Used to add a separator between rows that change year and quarter */
	let lastYear;
	let lastQuarter;

	let retrieveClassesForCourse = function (courseCode, offset, limit) {
		if (offset === 0) {
			$courseDataDiv.show().get(0).scrollIntoView({behavior: "smooth"});
			$courseDataDiv.hide();
		}
		return services.apiConnector.getClassesForCourse(courseCode, offset, limit).then(classSchedules => {
			if (offset === 0) {
				lastYear = lastQuarter = null;
				$courseDataDiv.find("h2").text(`Resultados para ${courseCode}`);
				$courseDataDiv.show();
				$courseDataDiv.find("table tbody")
					.html(`
					<tr><th colspan="2">Cuatr.</th><th>Curso</th><th>Anexo</th><th>Horario</th><th>Profesores</th></tr>
					<tr><td colspan="6"><a href="#">Ver mas resultados...</a></td></tr>`);
				$courseDataDiv.find("table tbody tr:last a").on("click", function () {
					services.utils.runAsync("retrieveClassesForCoursePage", () => retrieveClassesForCourse(courseCode, offset += limit, limit));
					return false;
				});
			}
			if (classSchedules.length < limit) {
				$courseDataDiv.find("table tbody tr:last").hide();
			}
			appendClassesToTable(classSchedules);
		});
	};

	let appendClassesToTable = function (classSchedules) {
		let trs = classSchedules.map(classSchedule => {
			let professorLis = (classSchedule.professors || []).map(professor => {
				return services.utils.getProfessorLi(professor);
			}).join("");
			let trClass = (lastYear && lastYear !== classSchedule.year) ? "top-border" : (lastQuarter && lastQuarter !== classSchedule.quarter) ? "top-border-without-first-cell" : "";
			lastYear = classSchedule.year;
			lastQuarter = classSchedule.quarter;
			return `<tr class="${trClass}">
					<td>${classSchedule.year}</td>
					<td>${classSchedule.quarter}</td>
					<td>${classSchedule.classCode}</td>
					<td>${classSchedule.branch || "-"}</td>
					<td>${services.utils.getSchedulesAsString(classSchedule.schedules)}</td>
					<td><ul class="no-margin">${professorLis}</ul></td>
				</tr>`;
		}).join("");
		$courseDataDiv.find("table tbody tr:last").before(trs);
	};


	return {
		init: function () {
			return Promise.resolve().then(() => {
				createPage();
				let courseCode = new URLSearchParams(window.location.search).get(UtnBaHelper.CoursesSearchCustomPage.customParamKey);
				if (courseCode) {
					return retrieveClassesForCourse(courseCode, 0, 15);
				}
			});
		},
		close: function () {
		},
	};
};

UtnBaHelper.CoursesSearchCustomPage.menuName = "Buscar cursos";
UtnBaHelper.CoursesSearchCustomPage.customParamKey = "courseCode";
if (!window.UtnBaHelper) window.UtnBaHelper = {};
UtnBaHelper.PlanTrackingCustomPage = function ($container, services) {

	const TRANSLATIONS = {
		"SIGNED": "Firmada",
		"PASSED": "Aprobada",
		"REGISTER": "Cursar",
		"TAKE_FINAL_EXAM": "Rendir final",
	};

	let $gradesSummary;
	let $plan;

	let createPage = function (planCode, coursesHistory) {
		let promises = [];

		$container.append(`<h3>Plan ${planCode}</h3>`);

		$gradesSummary = $("<div></div>");
		$container.append($gradesSummary);
		promises.push(buildGradesSummary(coursesHistory));

		$container.append("<hr>");

		$plan = $("<div></div>");
		$container.append($plan);
		promises.push(loadPlan(planCode, coursesHistory));

		return Promise.all(promises);
	};

	let buildGradesSummary = function (coursesHistory) {
		let startYear = coursesHistory.courses.concat(coursesHistory.finalExams)
			.map(course => course.date)
			.sort((a, b) => a - b)
			.map(date => date.getFullYear())
			[0];
		if (!startYear) return; // If no courses nor finalExams, there is nothing we can show.
		let yearsCount = (new Date().getFullYear() - startYear + 1);

		const arrayAverage = arr => Math.round(arr.reduce((a, b) => a + b, 0) / arr.length * 100) / 100;

		let passedFinalExams = coursesHistory.finalExams.filter(course => course.isPassed);
		let failedFinalExams = coursesHistory.finalExams.filter(course => !course.isPassed);
		let pesoAcademico = 11 * passedFinalExams.length - 5 * yearsCount - 3 * failedFinalExams.length;

		// Some final exams do not have grade (e.g. "Equivalencia Total") so we ignore them for the average.
		let passedWeightedGrades = passedFinalExams.filter(course => typeof course.weightedGrade === "number").map(course => course.weightedGrade);
		let failedWeightedGrades = failedFinalExams.filter(course => typeof course.weightedGrade === "number").map(course => course.weightedGrade);
		let passedNonWeightedGrades = passedFinalExams.filter(course => typeof course.grade === "number").map(course => course.grade);
		let failedNonWeightedGrades = failedFinalExams.filter(course => typeof course.grade === "number").map(course => course.grade);

		let allWeightedGradesAverage = arrayAverage(passedWeightedGrades.concat(failedWeightedGrades));
		let passedWeightedGradesAverage = arrayAverage(passedWeightedGrades);
		let allNonWeightedGradesAverage = arrayAverage(passedNonWeightedGrades.concat(failedNonWeightedGrades));
		let passedNonWeightedGradesAverage = arrayAverage(passedNonWeightedGrades);

		$gradesSummary.html(`<table><tbody></tbody></table>(*) La nota ponderada es calculada por el "UTN.BA Helper" segun Ordenanza Nº 1549`);
		const appendTableRow = (description, value) => $gradesSummary.find("tbody").append("<tr><td>" + description + "</td><td><b>" + (value || value === 0 ? value : "n/a") + "</b></td></tr>");

		appendTableRow("Peso academico", `${pesoAcademico} <small>(11*${passedFinalExams.length} - 5*${yearsCount} - 3*${failedFinalExams.length})</small>`);
		appendTableRow("Cantidad de finales aprobados", passedFinalExams.length);
		appendTableRow("Cantidad de finales desaprobados", failedFinalExams.length);
		appendTableRow("Promedio de notas ponderadas <sup>(*)</sup> con desaprobados", allWeightedGradesAverage);
		appendTableRow("Promedio de notas ponderadas <sup>(*)</sup> sin desaprobados", passedWeightedGradesAverage);
		appendTableRow("Promedio de notas originales <sup>(*)</sup> con desaprobados", allNonWeightedGradesAverage);
		appendTableRow("Promedio de notas originales <sup>(*)</sup> sin desaprobados", passedNonWeightedGradesAverage);

		return services.dataCollector.logUserStat(pesoAcademico, passedWeightedGradesAverage, allWeightedGradesAverage, passedFinalExams.length, failedFinalExams.length);
	};

	//...

	let loadPlan = function (planCode, coursesHistory) {
		if (!planCode) return;
		return services.apiConnector.getPlanCourses(planCode).then(planCourses => {
			return loadPlanCourses(planCourses, coursesHistory);
		});
	};

	let loadPlanCourses = function (planCourses, coursesHistory) {
		let courseNamesByCode = planCourses.reduce(function (courseNamesByCode, course) {
			courseNamesByCode[course.courseCode] = course.courseName;
			return courseNamesByCode;
		}, {});

		// For signed courses we consider both passed and signed, and remove duplicates.
		let passedCourses = coursesHistory.finalExams.filter(course => course.isPassed).map(course => course.courseCode);
		let signedCourses = [...new Set([...passedCourses, ...coursesHistory.courses.filter(course => course.isPassed).map(course => course.courseCode)])];
		let courseRequirementToArray = {
			"SIGNED": signedCourses,
			"PASSED": passedCourses,
		};
		let hasCourse = (requirement, courseCode) => courseRequirementToArray[requirement].includes(courseCode);

		let getCoursesHtml = level => {
			let lastWasElective = false;
			let showExtraElectivesButtonAdded = false;
			return planCourses.filter(course => {
				return course.level === level;
			}).map(course => {
				let meetsDependencies = kind => course.dependencies
					.filter(dependency => dependency.kind === kind)
					.every(dependency => hasCourse(dependency.requirement, dependency.courseCode));
				course.isSigned = hasCourse("SIGNED", course.courseCode);
				course.isPassed = hasCourse("PASSED", course.courseCode);
				course.canRegister = meetsDependencies("REGISTER");
				course.canTakeFinalExam = meetsDependencies("TAKE_FINAL_EXAM");
				return course;
			}).sort((c1, c2) => {
				let courseWeight = course => {
					let w;
					if (course.isPassed) w = 10;
					else if (course.canTakeFinalExam) w = 9;
					else if (course.isSigned) w = 8;
					else if (course.canRegister) w = 7;
					else w = 6;
					if (course.elective) {
						w -= 5;
					}
					return w;
				};
				return courseWeight(c2) - courseWeight(c1);
			}).map(course => {
				let status;
				let backgroundColor = "#7e7e7e";
				let color = "#000000";
				if (course.isPassed) {
					status = TRANSLATIONS["PASSED"];
					backgroundColor = "#55bb55";
				} else if (course.canTakeFinalExam) {
					status = "Puede " + TRANSLATIONS["TAKE_FINAL_EXAM"].toLowerCase();
					backgroundColor = "#ffcc00";
				} else if (course.isSigned) {
					status = TRANSLATIONS["SIGNED"];
					backgroundColor = "#ffcc00";
				} else if (course.canRegister) {
					status = "Puede " + TRANSLATIONS["REGISTER"].toLowerCase();
					backgroundColor = "#5555bb";
					color = "#f1f1f1";
				}

				let hr = "";
				if (!lastWasElective && course.elective) {
					lastWasElective = true;
					hr = `<hr><div>Electivas:</div>`;
				}

				let divClass = "";
				let showExtraElectivesButton = "";
				if (course.elective && !course.isPassed && !course.canTakeFinalExam && !course.isSigned) {
					divClass = "hidden";
					if (!showExtraElectivesButtonAdded) {
						showExtraElectivesButtonAdded = true;
						showExtraElectivesButton = `<a href="#" class="show-electives" data-level="${level}">> Mostrar todas</a>`;
					}
				}

				let getDependenciesLines = dependencyKind => course.dependencies
					.filter(dependency => dependency.kind === dependencyKind)
					.map(dependency => {
						let line = `${TRANSLATIONS[dependency.requirement]} [${dependency.courseCode}] ${courseNamesByCode[dependency.courseCode] || ""}`;
						if (hasCourse(dependency.requirement, dependency.courseCode)) line = `<s>${line}</s>`;
						return line;
					})
					.join("<br>");

				return `
					${hr}
					${showExtraElectivesButton}
					<div class="course level-${level} ${divClass}" style="background-color:${backgroundColor};color:${color}">
						<a href="#" onclick="return false" style="float: right;">
							<i class="icon-info-sign"></i>
							<span class="dependency-tooltip">
								<u>Para ${TRANSLATIONS["REGISTER"].toLowerCase()}</u>:<br>
								${getDependenciesLines("REGISTER")}
								<br><br>
								<u>Para ${TRANSLATIONS["TAKE_FINAL_EXAM"].toLowerCase()}</u>:<br>
								${getDependenciesLines("TAKE_FINAL_EXAM")}
							</span>
						</a>
						<div class="text-small">[${course.courseCode}] ${status ? " - " + status : ""}</div>
						<div class="text-medium">${course.courseName}<a class="no-ajax" href="${UtnBaHelper.CustomPages.getCourseResultsUrl(course.courseCode)}" target="_blank">&#x2197;</a></div>
					</div>`;
			}).join("");
		};

		let levels = [...new Set(planCourses
			.filter(course => course.level !== 0) // TODO this should be removed if we update courses...
			.map(course => course.level))]
			.sort();

		let ths = levels.map(level => `<th>Nivel ${level}</th>`).join("");
		let tds = levels.map(level => `<td>${getCoursesHtml(level)}</td>`).join("");
		$plan.html(`
			<table class="plan-tracking">
				<tbody>
					<tr>${ths}</tr>
					<tr>${tds}</tr>
				</tbody>
			</table>
		`);

		$plan.find("table").on("click", ".show-electives", function () {
			let level = $(this).attr("data-level");
			$plan.find(`table .course.level-${level}`).removeClass("hidden");
			$(this).remove();
			return false;
		});
	};


	return {
		init: function () {
			return Promise.resolve().then(() => {
				return Promise.all([
					services.pagesDataParser.getStudentPlanCode(),
					services.pagesDataParser.getCoursesHistory(),
				]);
			}).then(result => {
				let planCode = result[0];
				let coursesHistory = result[1];
				return createPage(planCode, coursesHistory);
			});
		},
		close: function () {
		},
	};
};

UtnBaHelper.PlanTrackingCustomPage.menuName = "Seguimiento de Plan";
UtnBaHelper.PlanTrackingCustomPage.customParamKey = "";
if (!window.UtnBaHelper) window.UtnBaHelper = {};
UtnBaHelper.CustomPages = function (pagesDataParser, dataCollector, utils, apiConnector) {

	const CUSTOM_PAGES = [
		UtnBaHelper.CoursesSearchCustomPage,
		UtnBaHelper.ProfessorsSearchCustomPage,
		UtnBaHelper.PlanTrackingCustomPage,
	];

	let appendMenu = function () {
		if (!CUSTOM_PAGES.length) return;

		let $customMenusContainer = $(`<ul class="dropdown-menu"></ul>`);
		let $li = $(`
				<li class="dropdown js-menuitem-root">
					<a href="#" class="dropdown-toggle" data-toggle="dropdown">UTN.BA Helper <b class="caret"></b></a>
				</li>`);
		$li.append($customMenusContainer);
		$(".main-nav .nav:not(.perfiles)").append($li);

		CUSTOM_PAGES.forEach(customPage => {
			$customMenusContainer.append(`<li><a class="no-ajax" href="${UtnBaHelper.CustomPages.getCustomPageUrl(customPage)}">${customPage.menuName}</a></li>`);
		});
	};

	let initCustomPage = function (customPage) {
		$("#kernel_contenido").html(`
			<div class="utnba-helper">
				<div class="alert info">
					<h3 style="text-align: center;">UTN.BA HELPER - Información importante</h3>
					<p><b>Esta sección es provista por el "UTN.BA Helper" y no es parte del sistema de la UTN.</b></p>
					<p>La información presentada en esta sección proviene de datos colectados de los usuarios que poseen la extensión, y de informacion generada por la misma extension, por lo cual puede estar incompleta y/o errónea. <br>
					Ninguno de los datos presentados en esta sección proviene del sistema de la UTN, por lo que debe ser usada bajo su propia interpretación.</p>
					<p>Tener en cuenta que en los casos de encuestas, la informacion colectada es una muestra parcial del total real, y por ende en casos donde la muestra es muy baja, puede implicar que los resultados estén alejados de la realidad.</p>
				</div>
				<div class="main">
					<div class="titulo_operacion"><h2 class="clearfix"><span class="pull-left">${customPage.menuName}</span></h2></div>
				</div>
				<div class="alert">
					<h3 style="text-align: center;">Esta sección es provista por el "UTN.BA Helper" y no es parte del sistema de la UTN.</h3>
				</div>
			</div>
		`);
	};

	let getSelectedPageHandler = function () {
		let selectedCustomPageName = new URLSearchParams(window.location.search).get(UtnBaHelper.CustomPages.CUSTOM_PAGE_QUERY_PARAM);
		let selectedCustomPage = CUSTOM_PAGES.filter(customPage => selectedCustomPageName === customPage.menuName)[0];
		if (!selectedCustomPage) return null;

		return () => {
			initCustomPage(selectedCustomPage);
			return selectedCustomPage($("#kernel_contenido .main"), {
				pagesDataParser,
				dataCollector,
				utils,
				apiConnector
			});
		};
	};


	// Public
	return {
		appendMenu: appendMenu,
		getSelectedPageHandler: getSelectedPageHandler,
	};
};

UtnBaHelper.CustomPages.CUSTOM_PAGE_QUERY_PARAM = "customPage";

UtnBaHelper.CustomPages.getCustomPageUrl = function (customPage, customParamValue) {
	let params = {
		[UtnBaHelper.CustomPages.CUSTOM_PAGE_QUERY_PARAM]: customPage.menuName,
		[customPage.customParamKey]: customParamValue,
	};
	return "/autogestion/grado/?" + Object.entries(params).filter(entry => !!entry[1]).map(entry => entry.map(encodeURIComponent).join("=")).join("&");
};

UtnBaHelper.CustomPages.getCourseResultsUrl = function (courseCode) {
	return UtnBaHelper.CustomPages.getCustomPageUrl(UtnBaHelper.CoursesSearchCustomPage, courseCode);
};

UtnBaHelper.CustomPages.getProfessorSurveyResultsUrl = function (professorName) {
	return UtnBaHelper.CustomPages.getCustomPageUrl(UtnBaHelper.ProfessorsSearchCustomPage, professorName);
};
(function () {
	let apiConnector = new UtnBaHelper.ApiConnector();
	let utils = new UtnBaHelper.Utils(apiConnector);
	return utils.runAsync("main", () => {
		let store = new UtnBaHelper.Store();
		let pagesDataParser = new UtnBaHelper.PagesDataParser(utils);
		let dataCollector = new UtnBaHelper.DataCollector(store, pagesDataParser, apiConnector);
		let customPages = new UtnBaHelper.CustomPages(pagesDataParser, dataCollector, utils, apiConnector);

		// We only will handle pages if:
		// - the user is in the /autogestion/grado pages
		// - the user is logged in (they have the name in the navbar)
		// - there is a profile selector with "Alumno" selected.
		let isInGradoPage = window.location.pathname.startsWith("/autogestion/grado");
		let isLoggedIn = !!$(".user-navbar").length;
		let currentProfile = $("#js-selector-perfiles .js-texto-perfil").text().trim();
		let isStudentProfile = currentProfile === "Perfil: Alumno";
		if (!isInGradoPage || !isLoggedIn || !isStudentProfile) {
			return apiConnector.logMessage("pageNotHandled", false, `[Path:${window.location.pathname}][IsLoggedIn:${isLoggedIn}][CurrentProfile:${currentProfile}]`);
		}

		customPages.appendMenu();

		const PAGE_HANDLERS = {
			// match is performed using startsWith and first one is used.
			"/autogestion/grado/calendario": () => UtnBaHelper.HorariosPage(),
			"/autogestion/grado/cursada/elegir_materia/": () => UtnBaHelper.PreInscripcionPage(pagesDataParser, utils, apiConnector),
			"/autogestion/grado/examen": () => UtnBaHelper.InscripcionAExamenesPage(),
		};

		let currentHandler = null;
		let handleCurrentPage = () => utils.runAsync("HandlePage " + window.location.pathname + window.location.search, () => {
			if (currentHandler) currentHandler.close();

			// Wait for the loading div to hide... applies for both loading from document or ajax.
			return utils.waitForElementToHide("#loading_top").then(() => {
				currentHandler = customPages.getSelectedPageHandler() || Object.entries(PAGE_HANDLERS).filter(entry => window.location.pathname.startsWith(entry[0])).map(entry => entry[1])[0];
				if (!currentHandler) return;
				currentHandler = currentHandler();
				return currentHandler.init();
			});
		});

		// noinspection JSIgnoredPromiseFromCall
		handleCurrentPage();

		// Append the foreground script that will subscribe to all the needed events.
		utils.injectScript("js/guarani/foreground.js");

		// Subscribe to ajax page changes (some of these events are created in the foreground script)
		window.addEventListener("locationchange", handleCurrentPage);

		// noinspection JSIgnoredPromiseFromCall
		utils.runAsync("collectBackgroundDataIfNeeded", () => dataCollector.collectBackgroundDataIfNeeded());

		$(".user-navbar").closest(".row-fluid").prepend(`<span class="powered-by-utnba-helper"></span>`);
		$("body").on("click", ".powered-by-utnba-helper", function () {
			window.open("https://chrome.google.com/webstore/detail/jdgdheoeghamkhfppapjchbojhehimpe", "_blank");
		});
	});
})();
